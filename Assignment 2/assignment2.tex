%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% CMPT 435
% Lab Zero
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from: http://www.LaTeXTemplates.com
% Original author: % Frits Wenneker (http://www.howtotex.com)
% License: CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% Modified by Alan G. Labouseur  - alan@labouseur.com, and Patrick Tyler - Patrick.Tyler1@marist.edu
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[letterpaper, 10pt]{article} 

\usepackage[english]{babel} % English language/hyphenation
\usepackage{graphicx}
\usepackage[lined,linesnumbered,commentsnumbered]{algorithm2e}
\usepackage{listings}
\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\usepackage{lastpage}
\usepackage{url}
\usepackage{xcolor}
\usepackage{titlesec}

% Stolen from https://www.overleaf.com/learn/latex/Code_listing 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle, language=c++}


\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{page \thepage\ of \pageref{LastPage}} % Page numbering for center footer
\fancyfoot[R]{}

\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{	
   \normalfont \normalsize 
   \textsc{CMPT 435 - Fall 2023 - Dr. Labouseur} \\[10pt] % Header stuff.
   \horrule{0.5pt} \\[0.25cm] 	% Top horizontal rule
   \huge Assignment Two -- \LaTeX ~Data\\     	    % Assignment title
   \horrule{0.5pt} \\[0.25cm] 	% Bottom horizontal rule
}

\author{Patrick Tyler \\ \normalsize Patrick.Tyler1@marist.edu}

\date{\normalsize\today} 	% Today's date.

\begin{document}

\maketitle % Print the title

%----------------------------------------------------------------------------------------
%   CONTENT SECTION
%----------------------------------------------------------------------------------------

% - -- -  - -- -  - -- -  -
\section{Linear and Binary Searches}
\subsection{Linear Search}
A linear search is one of the most flexible search algorithms. The only requirement of this search is that
the collection of elements can be traversed and checked for equality. This algorithm simply goes through
each element and checks for equality. This algorithm works in linear time big oh of n because in the worse
case it checks every element for equality.
\subsection{Binary Search}
For a binary search to be applicable, the collection must be sorted (therefore of comparable elements)
and random access. An array of sorted elements is the most common data type in which a binary search
can be done on. An array is random access because an element can be accessed at any time with its
given index.\\
\newline
This algorithm works with the following process: (1) picking the midpoint of its bounds;
(2) check equality between midpoint value and target if equal, element is found;
(3) check whether midpoint value is greater/ lesser than target then set lower / upper bound to
midpoint -1 / +1 and repeat to step 1 if the upper bound does is not equal or lower than the lower bound. 
How the bounds change also depends on if the array is in ascending or descending order.
The following is a code example of binary search on an ascending array.
\section{Hashmap Search}
\subsection{Prerequisites}
For a hashmap search to be implemented the data has to be stored in well... a hashmap. A hashmap maps
a value to a key with a hash function. In an array implementation the key would be an index. A hash function
should be able to hash an indefinite number of inputs depending only on the constraints of the data type. 
Ideally this mapping is 1 to 1, but practically mapping an indefinite number of inputs to a key requires
also an indefinite amount of space to store the value at each given key. Thus, there may be collisions
where values map to the same key; this will have to be dealt with through storing a collection with each key
which can dynamically increase in size such as a linked list. The 

\subsection{A Perfect Hash Function}
A perfect hash function maps every valid value as a unique key. Let's see how many keys
are needed to create a perfect hash function for 8 bit ascii strings. Each ascii character
has $2^8$ or 256 different possibilities. So, if the hash function only hashes
a single ascii character it will need 256 different keys. If the valid input is extended each
additional character will multiply the number of different keys needed by 256 because there will be an
additional 256 valid strings for each already existing combination. To be able to hash length 8
strings there will need to be $256^8$ or $2^{64}$ keys. Each key will need 8 bytes
(for instance, numbers\\ 0 through $2^{64}-1$) of information 
to store it's position; it will also need an additional bit to store whether it exists in
the hashmap (it will not need to store the string itself because that can be obtained from the key).
In total, this hashmap will have to store $65 * 2^{64}$ bits. This is about 150 \textit{exabytes}. The amount
of storage -- \textit{not even working memory} -- in all of the world's computer is estimated to be about double that. So, it is safe to say:
prefect hashes are impractical.

    

\vspace{.25cm}
\hrule
\vspace{.25cm}
\noindent
Girl: \textit{I think we need to take some space from eachother.}\\
Guy: \textit{Great! Then we'll spend more time together.}\\
Girl: \textit{What?}\\
Guy: \textit{It's a classic tradeoff: space versus time. "Taking space" will allow has to spend more time}.\\
\textit{* 10 second pause *}\\
Girl: \textit{I've been cheating on you for 5 years.}\\

\hrule
\vspace{1cm}
\section{Analysis of Searches}


\end{document}